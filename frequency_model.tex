\newcommand{\code}[1]{\texttt{#1}}

\subsection{Overview}
The frequency cost model uses the foundations of the maintenance cost model, but
replaces the unprioritized ordering with a prioritized ordering of frequency
cost, asymptotic runtime, max storage, true runtime, and true size.

This model approaches optimization in a way that lets the user specify which
query or mutator is more important than the other, and calculates the costs of
expressions accordingly so that Cozy will find the implementation that is better
tailored to how the user thinks the specification will be used.

\subsection{The Problem}
In both the original model and the maintenance cost model, there was no way for
the user to specify the importance (or frequency of usage) of a query or a
mutator, this could be useful for specifications that could be implemented in
several different ways, each way more efficient for different queries or
mutators. For example, this specification:

\begin{lstlisting}
    Product:
        state xs : Bag<Int>
        state ys : Bag<Int>

        query product()
            [(x, y) | x <- xs, y <- ys]

        op add_x(x : Int)
            xs.add(x);
\end{lstlisting}

Can produce a state that is a list of all \code{(x, y)} tuples. This solution is
inefficient for the mutator. When an \code{x} is added, the list of tuples will
grow in size by the cardinality of the bag \code{ys}. In the original and the
maintenance cost model, there is a heuristic in place to prevent Cozy from
outputting this solution. However, this solution could be more efficient if the
query is used significantly more than the mutator. If we allow the user to
specify this information, not only will Cozy have one less heuristic, it will
also produce implementations that are more tailored to how they will be used.

\subsection{Challenge}
