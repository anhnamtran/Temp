\newcommand{\code}[1]{\texttt{#1}}

\subsection{Overview}
With the original cost model, there were no connections between queries and
mutators. This means that when it is optimizing a query, it is doing so
regardless how that would affect the performance of the mutators.
The maintenance cost model is provided with information on what mutators (or
\code{op}s) that exists in the specification. It will then calculate the cost to
maintain expressions when there are mutator to be considered.

\subsection{Improvements}
With the original cost model, there is a chance Cozy will output implementaions
in which a state variable is highly efficient when a query is ran on it, but
is inefficient when a mutator is ran. For example, given this specification:

\begin{lstlisting}
    Cats:
        state cats: Set<Cat>

        query countSharedColor(c : Cat)
            assume c in cats;
            len [x | x <- cats, x.color == c.color]

        op addCat(c : Cat)
            cats.add(c);
\end{lstlisting}

Cozy will try to output an implementation that is a map from cats to the number
of other cats that have the same color. This implementation, when in the scope
of just the query, is very efficient. However, when the mutator \code{addCat} is
called, the map of cats will have to be updated in two ways: (1) every existing
cat with the same color as the new cat has to increment their count by 1, (2)
the new cat will have to calculate the number of existing cats that match its
color. When the number of cats is very large, it can lead to inefficiency. 

By allowing the cost model to also consider the maintenance cost of expressions
with respect to available mutators, Cozy should be able determine that storing
a map from colors to cats with the same colors is much more efficient overall.

\subsection{Challenge and Solution}
