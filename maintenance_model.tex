\newcommand{\code}[1]{\texttt{#1}}

\subsection{Overview}
With the original cost model, there were no connections between queries and
mutators. This means that when it is optimizing a query, it is doing so
regardless how that would affect the performance of the mutators. 
The maintenance cost model is provided with information on what mutators (or
\code{op}s) that exists in the specification. It will then calculate the cost to
maintain expressions when there are mutator to be considered.

\subsection{Improvements}
With the original cost model, there is a chance Cozy will output implementaions
in which a state variable is highly efficient when a query is ran on it, but
is inefficient when a mutator is ran. For example, given this specification: 

\begin{lstlisting}
    Cats:
        state cats: Set<Cat>

        query countSharedColor(c : Cat)
            assume c in cats;
            len [x | x <- cats, x.color == c.color]

        op addThing(c : Cat)
            cats.add(c);
\end{lstlisting}

\subsection{Challenge and Solution}
